{
	"nodes":[
		{"id":"2ae81c2e782d1c96","type":"group","x":-920,"y":-3100,"width":3420,"height":1980,"label":"References and learning notes"},
		{"id":"88be040a1b527cdb","type":"group","x":-1250,"y":-180,"width":2642,"height":1569,"label":"The Plan:tm:"},
		{"id":"c0788ba070d657e3","type":"text","text":"# What the HECK is a normal??\nNormals are very important for defining the orientation of a surface at a specific point.\nEssentially, a surface normal at a point $P$ on a surface is a vector that is perpendicular to the tangent plane at that point.\nAll that mumbo-jumbo basically means **it's pointing directly away from the surface**.\n## Normals, shading and you\nNormals are indispensable in the process of **shading an object**, determining the brightness and color of surfaces in a scene, based on the light sources present.\nBy looking at normals to know the orientation of surfaces, a shading algorithm can simulate the effects of lighting on an object.\n## Normals vs vectors\nIn terms of transformations, vectors and normals are still pretty different.\nThis is the case because the way normals interact with light and shadow depends on their orientation relative to light sources, not just their position in 3D space.\nAs such, transforming normals isn't as easy as transforming vectors, since doing so would heavily modify the lighting of an object.\n","x":120,"y":-3020,"width":640,"height":979,"color":"6"},
		{"id":"570b6633a523b168","type":"link","url":"https://upload.wikimedia.org/wikipedia/commons/9/95/Ray_Tracing_Illustration_First_Bounce.png","x":120,"y":-1955,"width":640,"height":720,"color":"6"},
		{"id":"9f19347e436b7818","type":"text","text":"# Right/left-handed systems\n\n> [!TODO] Research to be done!\n> The scratchapixel tutorial has a pretty in depth explanation of this concept.\n","x":840,"y":-3020,"width":640,"height":840,"color":"6"},
		{"id":"1b4417abf5c39d59","type":"text","text":"# Matrices\nMatrices are essentially **a set of transformations to apply to a vector or point** in 3D space.\nThese transformations can include translations rotations and scales, as the simplest examples.\nThis concept allows the coding part of transformations to be heavily streamlined.\n## Representations of matrices\nMost often, matrices are represented as two dimensional arrays of numbers.\nHere's a representation of a 3x5 matrix (most matrices in computer graphics are either 3x3 or 4x4).\n$$\n\\begin{bmatrix}\n1 & 3 & 7 & 9 & 0 \\\\\n3 & 3 & 0 & 8 & 3 \\\\\n9 & 1 & 0 & 0 & 1\n\\end{bmatrix}\n$$\nElements in matrices are called **coefficients** in our context.\nAs a notation example, $M_{ij}$ denotes the coefficient found at the intersection of row $i$ and column $j$. \n## Matrix multiplication\n$$\nM_3 = M_1 * M_2\n$$\nMultiplying matrices results in a new matrix, called the **matrix product**.\nIt's essentially the combination of two matrices' transformations into one, as shown in the figure below.\n![Multiplying matrices](https://scratchapixel.com/images/geometry/matrixmult.png?)\n**A rule when multiplying matrices:** you can only multiply matrices if the number of columns in the first is **equal** to the number of rows in the second.\n> This means that matrices sized m x p and p x n can be multiplied to produce a matrix of dimensions m x n. Conversely, matrices sized p x m and n x p cannot be multiplied if m and n are unequal. For example, a 4x2 matrix can be multiplied with a 2x3 matrix to produce a 4x3 matrix. When multiplying two 4x4 matrices, the result is another 4x4 matrix, which aligns with our primary focus and simplifies our discussion.\n$$\n[M \\times P] * [P \\times N] = [M \\times N]\n$$\n\n\n> [!TODO] Research to be done!\n> I got a bit lazy, but there's a whole process to finding a particular coefficient of two multiplied matrices without calculating the whole resulting matrix.\n> Could be worth checking out.\n> It's in the matrices lesson of the scratch a pixel geometry lessons.\n\n","x":840,"y":-2120,"width":640,"height":885,"color":"6"},
		{"id":"c29e9501cd0cc6e9","type":"text","text":"# References\n- [42gitbook](https://42-cursus.gitbook.io/guide/4-rank-04/minirt/building-the-thing)\n- [Scratch a pixel Geometry lessons (highly recommended)](https://scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/geometry/points-vectors-and-normals.html)\n  Very nice overview of computer graphics relating to geometry\n  Has some #cpp examples too.\n  Read at least until the Matrices chapter.\n- [Wikipedia](https://en.wikipedia.org/wiki/Ray_tracing_(graphics))\n- [Computer Graphics from scratch](https://gabrielgambetta.com/computer-graphics-from-scratch/)\n- [3Blue1Brown Essence of linear algebra playlist](https://www.youtube.com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab)\n- [Medium article by 42 student](https://medium.com/@iremoztimur/building-a-minirt-42-project-part-1-ae7a00aebdb9)","x":-735,"y":-1480,"width":620,"height":320,"color":"6"},
		{"id":"b89a102546547704","type":"text","text":"# Currently reading\nComputer Graphics from Scratch - Basic Raytracing","x":-635,"y":-1720,"width":420,"height":205,"color":"6"},
		{"id":"8e64dff9e935f06f","type":"text","text":"# Rendering spheres\nblababla quadratic stuff","x":830,"y":-160,"width":542,"height":429,"color":"2"},
		{"id":"dae6f2240ec7195c","type":"text","text":"# Window management\nManaging the window with the minilibx\n\nAside from the usual event handling (red cross closing, esc closing etc), it should be pretty easy, especially the rendering part.\n\nWe only have to write colors pixel by pixel (since it's how the renderer does it)\nThe choice to do it gradually or all at once at the end of the rendering process is up to us, I believe\n\nThe most efficient way would be to write all pixels to a MLX image, and then write that same image to the screen in one time.","x":-570,"y":-120,"width":525,"height":460,"color":"4"},
		{"id":"6adb203214ffb9e7","type":"text","text":"# Logging\n\nI believe having some sort of logging done in the terminal window where miniRT is launched would be pretty cool, like a process indicator or something similar.","x":-1140,"y":20,"width":460,"height":220,"color":"#ababab"},
		{"id":"21a4e362b5c57a44","type":"text","text":"# Rendering planes","x":830,"y":381,"width":542,"height":429,"color":"2"},
		{"id":"80bfb89fd1aa6e92","type":"text","text":"# Renderer\n\n\n## Base principle\nCast rays through the camera's pixels, one ray for each pixel, starting from the camera's origin point.\nThe ray travels until it finds an object, and if so, calculates the amount of light that object at that location on its surface receives.","x":90,"y":460,"width":460,"height":480,"color":"1"},
		{"id":"cc782458fbca1386","type":"text","text":"# Parser\nReading the input files, creating a list of objects and their properties\n\n- File management (non-existent, empty files, etc.)\n- The types correspond to the requested types and nothing else\n- There is a MAXIMUM of one camera, one diffused light and one ambient light (there can be 0 or one, but no more!)\n- If it's a color, it has to be in the right range (0 - 255) and the same goes for orientation vectors (-1,1), etc. Make sure all digits are in the correct range for each type.\n- For each object, you also need to pay attention to its specific characteristics (whether the diameter or height of a cylinder is non-negative, for example, or other things).","x":-1230,"y":690,"width":660,"height":500,"color":"5"},
		{"id":"28e71b69d64d0e86","type":"text","text":"# Rendering cylinders","x":830,"y":940,"width":542,"height":429,"color":"2"},
		{"id":"eee0454edfcf79c7","type":"text","text":"# Scene creation\nObjective : simple to use functions to create each type of object we have to do.\nEach functions takes in properties and creates the object in the rendered world.\n\n## 3D world\nThe `y` axis is going to be the vertical axis.\n\n# Data structures\nStructs for 3D points, a different struct for all possible objects (spheres, cylinders, lights etc)\nStructs of object have the 3D point struct as one of their components\n","x":-480,"y":596,"width":496,"height":520,"color":"5"},
		{"id":"e65818c4cc47a2b3","type":"text","text":"# Rays of light and how to math them\n## The ray equation\n$$\nP = A + t(b - O)\n$$\nWe can express any point $P$ along a ray that starts at position $A$ in direction $b$ by modifying the value $t$, which is going to be any number that will move the point $P$ along the ray.\n![](https://raytracing.github.io/images/fig-1.02-lerp.jpg)\n\n","x":1540,"y":-3020,"width":860,"height":840,"color":"6"},
		{"id":"7662b9d9eafa7b3d","type":"text","text":"# What is a vector?\nMathematically speaking, a vector (also sometimes called a tuple in maths) is **a sequence of numbers**. That's about it.\nFor example, here is a vector of six elements.\n$$\nV = (a,b,c,d,e,f),\n$$\nEach of these letters $abcdef$ represent real numbers (1, 3, 4.56, -11, -11.08, 0, etc).\n## Isn't that really abstract?\nYeah. That's the point, actually.\n**Vectors can represent entirely different things when changing mathematical subjects.**\nIn general maths, for example, you'll hear vectors being described as containing an arbitrary or even infinite number of elements.\nIn computer graphics, however, **they're used to denote positions and/or directions in 3D space**.\nThat means the number of elements they contain are usually limited to 3 or 4.\n## What's the difference between points and vectors?\nPoints denote a **position** in 3D space. Just x, y, z.\nVectors, on the other hand, denote a **direction** and **magnitude** (like the force of gravity, the speed of an object, or a ray of light).\nVectors are often visualized as arrows starting from an origin point in 3D space and going in a specific direction.\nThe length of the arrow representation denotes the vector's magnitude.\nHere's an example where $x$, $y$ and $z$ are real numbers that define the vector's direction and magnitude in space:\n$$\nV = (x, y, z),\n$$\n### What's a magnitude?\nThe magnitude of a vector basically is it's length.\nThis isn't just relevant to how long the arrow is supposed to be when you draw it, it can also entail more information, like the strength of a force in physics, the speed of an object, and many more.\nIn computer graphics, \n## Normalizing vectors\nA vector is considered normalized when its length is **exactly 1**.\nThis means the direction stays the same, but you're scaling the magnitude to **a unit length**.\nThis practice simplifies calculations and ensure consistency across different operations (by keeping the scale of everything identical).\nOf coures, not every vector should be normalized if doing so would lead to loss of information.\nFor example, normalizing a vector denoting a distance between two points would be futile.\n\n> [!DANGER]\n> It's best to be careful about choosing to normalize a vector.\n> Does it serve a particular purpose?\n> Was the vector already normalized at some point?\n> Many such questions to ask just to make sure that it is a good idea.\n\n## So what can we do with vectors in 3D?\nVectors are subject to transformations: operations that alter their values in some way.\n### Examples of transformations\n#### Translation\nLet's start with a simple one: **moving points to a different location in space**.\nWhen we mention translating a point, we're meaning moving it somewhere else **without affecting anything other than its position**.\nIts orientation and size, for example, remain the same.\nIt's kind of picking up something and putting it elsewhere, without altering it in any other way.\nFor vectors, though, since they're not simple points in space, moving their location keeps them exactly the same (their direction and magnitude didn't change).\n\n#### Rotation\nIn the case of vectors, rotation is a bit more interesting, since it changes the vector's direction.\nAs with translation, nothing else gets altered. It's magnitude and origin point stay the same.\n### Math representation of these two transformations\n- Point transformation: $P \\to Translate \\to P_T$\n- Vector transformation: $V \\to Rotate \\to V_T$\nThe subscript $T$ means the transformed version of the original point/vector.\n## Some formulas to have fun with\n### Vector's length\n$$\n||V|| = \\sqrt{V.x * V.x + V.y * V.y + V.z * V.z}\n$$\n$||V||$ represents the vector $V$'s length. This is often called the **norm** or **magnitude** of a vector.\n### Normalizing a vector\n$$\n\\hat{V} = \\frac{V}{||V||}\n$$\nAlso known as a **unit vector**, this operation results in a vector of length 1.\nThe idea of this formula is **dividing each coordinate of a vector by its length**.\n\n> [!NOTE] Coding this operation\n> As an aside, you can optimize this operation in code by multiplying the coordinates by the inverse of the length of the vector, instead of dividing by the raw length.\n> This is useful because, usually, divisions are slower than multiplications for CPUs to perform.\n### Dot product of two vectors\n![Visualization of the dot product of A and B](https://scratchapixel.com/images/geometry/dotproduct.png)\n$$\nA \\cdot B = A.x * B.x + A.y * B.y + A.z * B.z\n$$\nAlso sometimes rendered as $\\left<A, B\\right>$.\nThis operation does not return a vector value, but a **scalar** (just a number).\nAs such, it's sometimes called the **scalar projection** of $A$ onto $B$ (because the result is the tip of $A$ projected onto the length of $B$).\nIf the tip of $A$ falls **behind** $B$ (the arrow points in the opposite direction), the dot product $A \\cdot B$ will be **negative**.\n\n> [!ABSTRACT] Dot product and length of a vector\n> If you look carefully at both formula, you'll realize that the length of a vector is really just the square root of the dot product of that vector with itself.\n> As such, we can say that the dot product of a vector with itself is equal to its length squared:\n> $$\n> ||V||^2 = V \\cdot V\n> $$\n\nDot products are useful for determining **the angle between two vectors**. For example, a dot product of 0 means the two vectors are perpendicular.\n### Cross product of two vectors\n![Visualization of the cross product of A and B, creating C](https://scratchapixel.com/images/geometry/crossproduct.png)\n$$\nC = A \\times B\n$$\nUnlike the dot product, the cross product yields a **vector value**.\nThe gist of it is, you take two vectors $A$ and $B$, and the cross product of these two vectors is a new vector $C$ that is **perpendicular** to both of them.\nIf $A$ and $B$ are perpendicular, they form a Cartesian coordinate system (just a $x, y$ two-axis system) as shown in the image above.\nTo calculate the cross product, you have this expanded formula:\n$$\n\\begin{aligned}\nC_X = A_Y \\times B_Z - A_Z \\times B_Y \\\\\nC_Y = A_Z \\times B_Z - A_X \\times B_Z \\\\\nC_Z = A_X \\times B_Y - A_Y \\times B_X\n\\end{aligned}\n$$\nThe vectors $A$ and $B$ define a plane, and $C$ stands perpendicular to that plane.\nCareful, the **sequence of vectors influences the cross product**.\n$A \\times B$ isn't equal to $B \\times A$. The sequence of vectors chosen depends on the handedness of the coordinates system.\n","x":-820,"y":-3020,"width":850,"height":1240,"color":"6"}
	],
	"edges":[
		{"id":"9a0669329cbc70a3","fromNode":"80bfb89fd1aa6e92","fromSide":"right","toNode":"8e64dff9e935f06f","toSide":"left"},
		{"id":"b1b221e71e4da933","fromNode":"80bfb89fd1aa6e92","fromSide":"right","toNode":"21a4e362b5c57a44","toSide":"left"},
		{"id":"a088979226011821","fromNode":"80bfb89fd1aa6e92","fromSide":"right","toNode":"28e71b69d64d0e86","toSide":"left"},
		{"id":"bcd9689af1091705","fromNode":"80bfb89fd1aa6e92","fromSide":"top","toNode":"dae6f2240ec7195c","toSide":"right"},
		{"id":"98c575382d7ef3fb","fromNode":"cc782458fbca1386","fromSide":"right","toNode":"eee0454edfcf79c7","toSide":"left"},
		{"id":"508bf0580fe5e290","fromNode":"eee0454edfcf79c7","fromSide":"right","toNode":"80bfb89fd1aa6e92","toSide":"left"}
	]
}